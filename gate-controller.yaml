substitutions:
  gate_move_duration: "15s"
  gate_move_duration_ms: "15000"
  auto_close_delay: "60s"
  auto_close_delay_ms: "60000"

  # Secrets - override via upload.sh or -s flags
  wifi_primary_ssid: "PLACEHOLDER"
  wifi_primary_password: "PLACEHOLDER"
  wifi_secondary_ssid: "PLACEHOLDER"
  wifi_secondary_password: "PLACEHOLDER"
  mqtt_broker: "PLACEHOLDER"
  mqtt_username: "PLACEHOLDER"
  mqtt_password: "PLACEHOLDER"
  ota_password: "PLACEHOLDER"

esphome:
  name: gate-controller
  friendly_name: Gate Controller
  includes:
    - wifi_switch.h
  on_boot:
    priority: 599  # Right after globals restored (600), well before WiFi connects (250)
    then:
      - lambda: |-
          ESP_LOGW("boot", "use_secondary_network = %s", id(use_secondary_network) ? "TRUE" : "FALSE");
          if (id(use_secondary_network)) {
            ESP_LOGW("boot", "SWITCHING to secondary: ${wifi_secondary_ssid}");
            wifi::WiFiAP ap;
            ap.set_ssid("${wifi_secondary_ssid}");
            ap.set_password("${wifi_secondary_password}");
            wifi::global_wifi_component->set_sta(ap);
          } else {
            ESP_LOGW("boot", "Using primary: ${wifi_primary_ssid}");
          }

esp32:
  board: arduino_nano_esp32
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_LOG_COLORS: "n"

wifi:
  ssid: ${wifi_primary_ssid}
  password: ${wifi_primary_password}
  fast_connect: true  # Skip scan - required for hidden SSID (farmlandMini)
  reboot_timeout: 15min  # Reboot if WiFi disconnected for 15 min

# Native ESPHome API disabled - using MQTT instead
# api:
#   encryption:
#     key: ${api_encryption_key}
#   reboot_timeout: 0s

# MQTT for Home Assistant
mqtt:
  broker: ${mqtt_broker}
  port: 8883
  username: ${mqtt_username}
  password: ${mqtt_password}
  discovery: true
  discovery_prefix: homeassistant
  topic_prefix: gate
  idf_send_async: true
  log_topic: null
  reboot_timeout: 15min  # Reboot if MQTT disconnected for 15 min
  on_connect:
    - logger.log: "MQTT Connected!"
  on_disconnect:
    - logger.log: "MQTT Disconnected!"
  certificate_authority: |
    -----BEGIN CERTIFICATE-----
    MIIFazCCA1OgAwIBAgIRAIIQz7DSQONZRGPgu2OCiwAwDQYJKoZIhvcNAQELBQAw
    TzELMAkGA1UEBhMCVVMxKTAnBgNVBAoTIEludGVybmV0IFNlY3VyaXR5IFJlc2Vh
    cmNoIEdyb3VwMRUwEwYDVQQDEwxJU1JHIFJvb3QgWDEwHhcNMTUwNjA0MTEwNDM4
    WhcNMzUwNjA0MTEwNDM4WjBPMQswCQYDVQQGEwJVUzEpMCcGA1UEChMgSW50ZXJu
    ZXQgU2VjdXJpdHkgUmVzZWFyY2ggR3JvdXAxFTATBgNVBAMTDElTUkcgUm9vdCBY
    MTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK3oJHP0FDfzm54rVygc
    h77ct984kIxuPOZXoHj3dcKi/vVqbvYATyjb3miGbESTtrFj/RQSa78f0uoxmyF+
    0TM8ukj13Xnfs7j/EvEhmkvBioZxaUpmZmyPfjxwv60pIgbz5MDmgK7iS4+3mX6U
    A5/TR5d8mUgjU+g4rk8Kb4Mu0UlXjIB0ttov0DiNewNwIRt18jA8+o+u3dpjq+sW
    T8KOEUt+zwvo/7V3LvSye0rgTBIlDHCNAymg4VMk7BPZ7hm/ELNKjD+Jo2FR3qyH
    B5T0Y3HsLuJvW5iB4YlcNHlsdu87kGJ55tukmi8mxdAQ4Q7e2RCOFvu396j3x+UC
    B5iPNgiV5+I3lg02dZ77DnKxHZu8A/lJBdiB3QW0KtZB6awBdpUKD9jf1b0SHzUv
    KBds0pjBqAlkd25HN7rOrFleaJ1/ctaJxQZBKT5ZPt0m9STJEadao0xAH0ahmbWn
    OlFuhjuefXKnEgV4We0+UXgVCwOPjdAvBbI+e0ocS3MFEvzG6uBQE3xDk3SzynTn
    jh8BCNAw1FtxNrQHusEwMFxIt4I7mKZ9YIqioymCzLq9gwQbooMDQaHWBfEbwrbw
    qHyGO0aoSCqI3Haadr8faqU9GY/rOPNk3sgrDQoo//fb4hVC1CLQJ13hef4Y53CI
    rU7m2Ys6xt0nUW7/vGT1M0NPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNV
    HRMBAf8EBTADAQH/MB0GA1UdDgQWBBR5tFnme7bl5AFzgAiIyBpY9umbbjANBgkq
    hkiG9w0BAQsFAAOCAgEAVR9YqbyyqFDQDLHYGmkgJykIrGF1XIpu+ILlaS/V9lZL
    ubhzEFnTIZd+50xx+7LSYK05qAvqFyFWhfFQDlnrzuBZ6brJFe+GnY+EgPbk6ZGQ
    3BebYhtF8GaV0nxvwuo77x/Py9auJ/GpsMiu/X1+mvoiBOv/2X/qkSsisRcOj/KK
    NFtY2PwByVS5uCbMiogziUwthDyC3+6WVwW6LLv3xLfHTjuCvjHIInNzktHCgKQ5
    ORAzI4JMPJ+GslWYHb4phowim57iaztXOoJwTdwJx4nLCgdNbOhdjsnvzqvHu7Ur
    TkXWStAmzOVyyghqpZXjFaH3pO3JLF+l+/+sKAIuvtd7u+Nxe5AW0wdeRlN8NwdC
    jNPElpzVmbUq4JUagEiuTDkHzsxHpFKVK7q4+63SM1N95R1NbdWhscdCb+ZAJzVc
    oyi3B43njTOQ5yOf+1CceWxG1bQVs5ZufpsMljq4Ui0/1lvh+wjChP4kqKOJ2qxq
    4RgqsahDYVvTH9w7jXbyLeiNdd8XM2w9U/t7y0Ff/9yi0GE44Za4rF2LN9d11TPA
    mRGunUHBcnWEvgJBQl9nJEiU0Zsnvgc/ubhPgXRR4Xq37Z0j4r7g1SgEEzwxA57d
    emyPxgcYxn/eR44/KJ4EBs+lVDR3veyJm+kXQ99b21/+jh5Xos1AnX5iItreGCc=
    -----END CERTIFICATE-----

# Disable native API (using MQTT instead)
# api:

ota:
  platform: esphome
  password: ${ota_password}

logger:
  level: INFO

# 1-Wire bus for DS18B20 temperature sensor
# Wiring: SDA/A4 terminal (data), 5V (VCC), GND
# Canaduino SDA/A4 -> A4 on Nano ESP32 -> GPIO 11
# IMPORTANT: 4.7kΩ pull-up resistor required between Data and VCC
one_wire:
  - platform: gpio
    pin: 11  # Canaduino SDA/A4 = GPIO 11

# Sensors
sensor:
  - platform: wifi_signal
    name: "WiFi RSSI"
    id: wifi_rssi
    update_interval: 60s
    icon: "mdi:wifi"

  - platform: dallas_temp
    name: "Gate Panel Temperature"
    id: gate_panel_temp
    index: 0  # Use first sensor found (change to address after discovery)
    update_interval: 60s
    icon: "mdi:thermometer"
    filters:
      - lambda: return x * 9.0 / 5.0 + 32.0;
    unit_of_measurement: "°F"

# Relay outputs - internal (controlled by scripts)
# Arduino Nano ESP32: D2=GPIO5, D3=GPIO6
switch:
  - platform: gpio
    pin: 6
    id: latch_relay
    internal: true
    restore_mode: ALWAYS_OFF

  - platform: gpio
    pin: 5
    id: move_relay
    internal: true
    restore_mode: ALWAYS_OFF

# Unused relay outputs - internal switches held OFF
# Arduino Nano ESP32: D4=GPIO7, D5=GPIO8, A2=GPIO3, A3=GPIO4
  - platform: gpio
    pin: 7
    id: relay3_unused
    internal: true
    restore_mode: ALWAYS_OFF

  - platform: gpio
    pin: 8
    id: relay4_unused
    internal: true
    restore_mode: ALWAYS_OFF

  - platform: gpio
    pin: 3
    id: relay5_unused
    internal: true
    restore_mode: ALWAYS_OFF

  - platform: gpio
    pin: 4
    id: relay6_unused
    internal: true
    restore_mode: ALWAYS_OFF

# Production MQTT controls for Home Assistant
button:
  - platform: template
    name: "P1 Button - Open"
    id: btn_open_gate
    icon: "mdi:gate"
    on_press:
      - script.execute: handle_p1

  - platform: template
    name: "P2 Button - Latch"
    id: btn_latch_gate
    icon: "mdi:lock-open-variant"
    on_press:
      - script.execute: handle_p2

  - platform: template
    name: "P3 Button - Switch Network"
    id: btn_switch_network
    icon: "mdi:wifi-sync"
    on_press:
      - script.execute: switch_network

  - platform: template
    name: "P5 Button - Restart"
    id: btn_restart
    icon: "mdi:restart"
    on_press:
      - logger.log: "Restart requested via P5"
      - delay: 500ms
      - lambda: 'App.safe_reboot();'

# Physical inputs
# Arduino Nano ESP32: D7=GPIO10 (DI1), D8=GPIO17 (DI2), D12=GPIO47 (DI3), D13=GPIO48 (DI4)
# PLC opto needs 5V source feed - INPUT_PULLDOWN, active HIGH when triggered
binary_sensor:
  - platform: gpio
    pin:
      number: 10
      mode: INPUT_PULLDOWN
    name: "Input P1 Move"
    id: p1_input
    icon: "mdi:numeric-1-box"
    filters:
      - delayed_on: 100ms
      - delayed_off: 100ms
    on_press:
      - script.execute: handle_p1

  - platform: gpio
    pin:
      number: 17
      mode: INPUT_PULLDOWN
    name: "Input P2 Latch"
    id: p2_input
    icon: "mdi:numeric-2-box"
    filters:
      - delayed_on: 100ms
      - delayed_off: 100ms
    on_press:
      - script.execute: handle_p2

  - platform: gpio
    pin:
      number: 48
      mode: INPUT_PULLDOWN
    name: "Input P4 Magneto"
    id: car_sensor_input
    icon: "mdi:car-connected"
    filters:
      - delayed_on: 100ms
      - delayed_off: 100ms
    on_press:
      - script.execute: handle_p4_on
    on_release:
      - script.execute: handle_p4_off

  - platform: gpio
    pin:
      number: 47
      mode: INPUT_PULLDOWN
    name: "Input P3 Network"
    id: p3_input
    icon: "mdi:wifi-sync"
    filters:
      - delayed_on: 100ms
      - delayed_off: 100ms
    on_press:
      - script.execute: switch_network

  # Relay state indicators (read-only in HA)
  - platform: template
    name: "Relay 1 Move"
    id: move_relay_state
    icon: "mdi:electric-switch"
    lambda: 'return id(move_relay).state;'

  - platform: template
    name: "Relay 2 Latch"
    id: latch_relay_state
    icon: "mdi:electric-switch"
    lambda: 'return id(latch_relay).state;'


# State tracking
globals:
  # Always assume CLOSED on reboot - no state restoration
  - id: gate_latched
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: last_move_time
    type: unsigned long
    restore_value: no
    initial_value: '0'
  - id: gate_closing
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: gate_opening
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: car_sensor_active
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: use_secondary_network
    type: bool
    restore_value: yes
    initial_value: 'false'
  # STOP state tracking
  - id: gate_stopped
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: stop_was_opening
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: stop_elapsed_ms
    type: unsigned long
    restore_value: no
    initial_value: '0'
  - id: movement_start_time
    type: unsigned long
    restore_value: no
    initial_value: '0'

# Gate state sensor
text_sensor:
  - platform: template
    name: "Gate Status"
    id: gate_state
    lambda: |-
      if (id(gate_latched)) return {"Latched"};
      if (id(gate_stopped)) return {"Stop"};
      if (id(gate_opening)) return {"Opening"};
      if (id(gate_closing)) return {"Closing"};
      // Open if car_sensor_active, or if within auto_close_delay window
      if (id(car_sensor_active)) return {"Open"};
      if (id(last_move_time) > 0 && (millis() - id(last_move_time) < ${auto_close_delay_ms})) return {"Open"};
      return {"Closed"};
    update_interval: 5s

  - platform: wifi_info
    ip_address:
      name: "IP Address"
      id: wifi_ip
      icon: "mdi:ip-network"

  - platform: template
    name: "WiFi Network"
    id: wifi_network
    icon: "mdi:wifi-cog"
    lambda: |-
      if (id(use_secondary_network)) {
        return {"${wifi_secondary_ssid}"};
      }
      return {"${wifi_primary_ssid}"};

# Scripts for gate logic
script:
  - id: do_move
    then:
      - logger.log: "Sending P1 to gate - move or stop"
      - switch.turn_on: move_relay
      - delay: 1s
      - switch.turn_off: move_relay

  - id: do_open
    then:
      - logger.log: "Opening gate"
      - lambda: 'id(movement_start_time) = millis();'
      - globals.set:
          id: gate_opening
          value: 'true'
      - component.update: gate_state
      - script.execute: do_move
      - script.execute: finish_opening

  - id: do_close
    then:
      - logger.log: "Closing gate"
      - script.stop: notify_auto_close
      - lambda: |-
          id(last_move_time) = 0;
          id(movement_start_time) = millis();
      - globals.set:
          id: gate_closing
          value: 'true'
      - component.update: gate_state
      - script.execute: do_move
      - script.execute: finish_closing

  - id: finish_opening
    mode: restart
    then:
      - delay: ${gate_move_duration}
      - logger.log: "Gate finished opening"
      - globals.set:
          id: gate_opening
          value: 'false'
      - lambda: 'id(last_move_time) = millis();'
      - component.update: gate_state
      # Schedule auto-close after 60s
      - script.execute: notify_auto_close

  - id: notify_auto_close
    mode: restart
    then:
      - delay: ${auto_close_delay}
      - if:
          condition:
            lambda: 'return !id(gate_latched) && !id(car_sensor_active) && !id(gate_stopped);'
          then:
            - logger.log: "Gate auto-closing - CLOSING"
            - lambda: |-
                id(last_move_time) = 0;
                id(movement_start_time) = millis();
            - globals.set:
                id: gate_closing
                value: 'true'
            - component.update: gate_state
            - delay: ${gate_move_duration}
            - logger.log: "Gate finished closing"
            - globals.set:
                id: gate_closing
                value: 'false'
            - component.update: gate_state

  - id: do_latch
    then:
      - if:
          condition:
            lambda: 'return id(gate_latched);'
          then:
            - logger.log: "Unlatching gate - CLOSING"
            - lambda: 'id(movement_start_time) = millis();'
            - globals.set:
                id: gate_latched
                value: 'false'
            - globals.set:
                id: gate_closing
                value: 'true'
            - component.update: gate_state
            - switch.turn_off: latch_relay
            - delay: 1s
            - script.execute: do_move
            - script.execute: finish_closing
          else:
            - logger.log: "Latching gate open - OPENING"
            - lambda: 'id(movement_start_time) = millis();'
            - globals.set:
                id: gate_opening
                value: 'true'
            - component.update: gate_state
            - switch.turn_on: latch_relay
            - script.execute: finish_opening_latched

  - id: finish_opening_latched
    mode: restart
    then:
      - delay: ${gate_move_duration}
      - logger.log: "Gate finished opening - LATCHED_OPEN"
      - globals.set:
          id: gate_opening
          value: 'false'
      - globals.set:
          id: gate_latched
          value: 'true'
      - component.update: gate_state


  - id: finish_closing
    mode: restart
    then:
      - delay: ${gate_move_duration}
      - logger.log: "Gate finished closing"
      - globals.set:
          id: gate_closing
          value: 'false'
      - lambda: 'id(last_move_time) = 0;'
      - component.update: gate_state

  - id: do_stop
    then:
      - logger.log: "STOP - halting gate movement"
      # Capture elapsed time and direction
      - lambda: |-
          id(stop_elapsed_ms) = millis() - id(movement_start_time);
          id(stop_was_opening) = id(gate_opening);
      # Stop any running finish scripts
      - script.stop: finish_opening
      - script.stop: finish_closing
      - script.stop: finish_opening_latched
      - script.stop: notify_auto_close
      # Clear movement states
      - globals.set:
          id: gate_opening
          value: 'false'
      - globals.set:
          id: gate_closing
          value: 'false'
      - globals.set:
          id: gate_stopped
          value: 'true'
      - component.update: gate_state
      - script.execute: do_move
      # Start auto-close timer from STOP
      - script.execute: auto_close_from_stop

  - id: resume_from_stop
    then:
      - logger.log: "Resuming from STOP in opposite direction"
      - globals.set:
          id: gate_stopped
          value: 'false'
      - script.stop: auto_close_from_stop
      - script.execute: do_move
      - if:
          condition:
            lambda: 'return id(stop_was_opening);'
          then:
            # Was opening, now closing for same duration
            - logger.log: "Was OPENING, now CLOSING"
            - lambda: 'id(movement_start_time) = millis();'
            - globals.set:
                id: gate_closing
                value: 'true'
            - component.update: gate_state
            - delay: !lambda 'return id(stop_elapsed_ms);'
            - logger.log: "Gate finished closing from STOP"
            - globals.set:
                id: gate_closing
                value: 'false'
            - lambda: 'id(last_move_time) = 0;'
            - component.update: gate_state
          else:
            # Was closing, now opening for same duration
            - logger.log: "Was CLOSING, now OPENING"
            - lambda: 'id(movement_start_time) = millis();'
            - globals.set:
                id: gate_opening
                value: 'true'
            - component.update: gate_state
            - delay: !lambda 'return id(stop_elapsed_ms);'
            - logger.log: "Gate finished opening from STOP"
            - globals.set:
                id: gate_opening
                value: 'false'
            - lambda: 'id(last_move_time) = millis();'
            - component.update: gate_state
            - script.execute: notify_auto_close

  - id: auto_close_from_stop
    mode: restart
    then:
      - delay: ${auto_close_delay}
      - if:
          condition:
            lambda: 'return id(gate_stopped) && !id(gate_latched) && !id(car_sensor_active);'
          then:
            - logger.log: "Auto-closing from STOP"
            - globals.set:
                id: gate_stopped
                value: 'false'
            - lambda: 'id(movement_start_time) = millis();'
            - globals.set:
                id: gate_closing
                value: 'true'
            - component.update: gate_state
            # Calculate closing duration
            - if:
                condition:
                  lambda: 'return id(stop_was_opening);'
                then:
                  # Was opening - close for same duration
                  - delay: !lambda 'return id(stop_elapsed_ms);'
                else:
                  # Was closing - close for remaining time
                  - delay: !lambda 'return ${gate_move_duration_ms} - id(stop_elapsed_ms);'
            - logger.log: "Gate finished auto-closing from STOP"
            - globals.set:
                id: gate_closing
                value: 'false'
            - lambda: 'id(last_move_time) = 0;'
            - component.update: gate_state

  - id: handle_p1
    then:
      - lambda: |-
          std::string state = id(gate_state).state;
          if (state == "Latched") {
            id(do_latch).execute();
          } else if (state == "Opening" || state == "Closing") {
            id(do_stop).execute();
          } else if (state == "Stop") {
            id(resume_from_stop).execute();
          } else if (state == "Open") {
            id(do_close).execute();
          } else {  // Closed
            id(do_open).execute();
          }

  - id: handle_p2
    then:
      - script.execute: do_latch

  - id: handle_p4_on
    then:
      - logger.log: "P4 Car sensor ON"
      - switch.turn_on: latch_relay
      - globals.set:
          id: car_sensor_active
          value: 'true'
      - script.stop: notify_auto_close
      - script.stop: auto_close_from_stop
      # Handle CLOSING separately (needs delays, can't be in lambda)
      - if:
          condition:
            lambda: 'return id(gate_state).state == "Closing";'
          then:
            - logger.log: "Gate was CLOSING - reversing via P4"
            - lambda: 'id(stop_elapsed_ms) = millis() - id(movement_start_time);'
            - script.stop: finish_closing
            - globals.set:
                id: gate_closing
                value: 'false'
            - lambda: 'id(movement_start_time) = millis();'
            - globals.set:
                id: gate_opening
                value: 'true'
            - component.update: gate_state
            - delay: !lambda 'return id(stop_elapsed_ms);'
            - logger.log: "Gate finished opening from P4 reverse"
            - globals.set:
                id: gate_opening
                value: 'false'
            - lambda: 'id(last_move_time) = millis();'
            - component.update: gate_state
            # If P4 released during reversal, start auto-close
            - if:
                condition:
                  lambda: 'return !id(car_sensor_active);'
                then:
                  - script.execute: notify_auto_close
          else:
            # Handle other states
            - lambda: |-
                std::string state = id(gate_state).state;
                if (state == "Closed") {
                  ESP_LOGI("gate", "Gate was Closed - now Opening via passthrough");
                  id(movement_start_time) = millis();
                  id(gate_opening) = true;
                  id(gate_state).update();
                  id(finish_opening).execute();
                } else if (state == "Open") {
                  ESP_LOGI("gate", "Gate is Open - resetting 60s timer");
                  id(last_move_time) = millis();
                  id(gate_state).update();
                } else if (state == "Stop") {
                  // P4 while STOP - need to open the gate
                  id(gate_stopped) = false;
                  if (id(stop_was_opening)) {
                    // Was opening - continue opening for remaining time
                    ESP_LOGI("gate", "Gate was STOP (opening) - continuing to open");
                    unsigned long remaining = ${gate_move_duration_ms} - id(stop_elapsed_ms);
                    id(movement_start_time) = millis() - id(stop_elapsed_ms);  // Adjust for elapsed
                    id(gate_opening) = true;
                    id(gate_state).update();
                    id(finish_opening).execute();
                  } else {
                    // Was closing - reverse and open fully
                    ESP_LOGI("gate", "Gate was STOP (closing) - reversing to open");
                    id(movement_start_time) = millis();
                    id(gate_opening) = true;
                    id(gate_state).update();
                    id(finish_opening).execute();
                  }
                }
                // OPENING, LATCHED_OPEN - no action needed

  - id: handle_p4_off
    then:
      - logger.log: "P4 Car sensor OFF"
      - switch.turn_off: latch_relay
      - globals.set:
          id: car_sensor_active
          value: 'false'
      # Start 60s timer if gate is OPEN
      - if:
          condition:
            lambda: 'return id(gate_state).state == "Open";'
          then:
            - logger.log: "Gate is OPEN - starting 60s timer"
            - lambda: 'id(last_move_time) = millis();'
            - script.execute: notify_auto_close

  - id: switch_network
    then:
      - lambda: |-
          id(use_secondary_network) = !id(use_secondary_network);
          if (id(use_secondary_network)) {
            ESP_LOGI("wifi", "Switching to ${wifi_secondary_ssid} - will restart");
          } else {
            ESP_LOGI("wifi", "Switching to ${wifi_primary_ssid} - will restart");
          }
      - component.update: wifi_network
      - delay: 500ms
      - lambda: |-
          App.safe_reboot();
